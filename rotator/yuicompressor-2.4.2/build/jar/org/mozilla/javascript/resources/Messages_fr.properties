#
# French JavaScript messages file.
#
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Aviva Inc. code, released
# March 5, 2004.
#
# The Initial Developer of the Original Code is
# Aviva Inc.
# Portions created by the Initial Developer are Copyright (C) 2004
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Eugene Aresteanu
#
# Alternatively, the contents of this file may be used under the terms of
# the GNU General Public License Version 2 or later (the "GPL"), in which
# case the provisions of the GPL are applicable instead of those above. If
# you wish to allow use of your version of this file only under the terms of
# the GPL and not to allow others to use your version of this file under the
# MPL, indicate your decision by deleting the provisions above and replacing
# them with the notice and other provisions required by the GPL. If you do
# not delete the provisions above, a recipient may use your version of this
# file under either the MPL or the GPL.
#
# ***** END LICENSE BLOCK *****

msg.dup.parms =\
 Le nom de param\u00E8tre "{0}" existe d\u00E9j\u00E0.
msg.too.big.jump =\
 Programme trop complexe : d\u00E9calage de saut trop important
msg.too.big.index =\
 Programme trop complexe : l''indice interne d\u00E9passe la limite de 64 ko
msg.ctor.not.found =\
 Le constructeur de "{0}" est introuvable
msg.not.ctor =\
 {0} n''est pas un constructeur
msg.varargs.ctor =\
 La m\u00E9thode ou le constructeur "{0}" doit \u00EAtre statique avec la signature "(Context cx, arguments Object[], Function ctorObj, boolean inNewExpr)" pour d\u00E9finir un constructeur d''arguments de variable.
msg.varargs.fun =\
 La m\u00E9thode "{0}" doit \u00EAtre statique avec la signature "(Context cx, Scriptable thisObj, arguments Object[], Function funObj)" pour d\u00E9finir une fonction d''arguments de variable
msg.incompat.call =\
 La m\u00E9thode "{0}" a \u00E9t\u00E9 appel\u00E9e dans un objet non compatible
msg.bad.parms =\
 Les param\u00E8tres de la m\u00E9thode sont incorrects pour "{0}"
msg.no.overload =\
 La m\u00E9thode "{0}" appara\u00EEt plusieurs fois dans la classe "{1}"
msg.method.not.found =\
 La m\u00E9thode "{0}" est introuvable dans "{1}"
msg.bad.for.in.lhs =\
 La partie gauche de la boucle for..in est incorrecte
msg.bad.lhs.assign =\
 La partie gauche de l''affectation est incorrecte
msg.mult.index =\
 Une seule variable est autoris\u00E9e dans la boucle for..in
msg.cant.convert =\
 La conversion en type "{0}" est impossible
msg.cant.call.indirect =\
 La fonction "{0}" doit \u00EAtre appel\u00E9e directement et non par l''interm\u00E9diaire d''une fonction portant un autre nom
msg.eval.nonstring =\
 Si vous appelez la fonction eval() avec une valeur qui n''appartient pas \u00E0 une cha\u00EEne primitive, c''est la valeur en question qui est renvoy\u00E9e. \u00E9tait-ce votre intention ?
msg.only.from.new =\
 {0} ne peut \u00EAtre appel\u00E9e qu''\u00E0 partir d''une "nouvelle" expression.
msg.deprec.ctor =\
 Le constructeur "{0}" est d\u00E9conseill\u00E9
msg.no.function.ref.found =\
 aucune source n''a \u00E9t\u00E9 trouv\u00E9e pour d\u00E9compiler la r\u00E9f\u00E9rence de fonction {0}
msg.arg.isnt.array =\
 le second argument de la m\u00E9thode Function.prototype.apply doit \u00EAtre un tableau
msg.bad.esc.mask =\
 le masque d''\u00E9chappement de cha\u00EEne est incorrect
msg.cant.instantiate =\
 erreur lors de l''instanciation ({0}) : la classe {1} est une classe interface ou abstract
msg.bad.ctor.sig =\
 Un constructeur avec une signature incorrecte a \u00E9t\u00E9 d\u00E9tect\u00E9 : {0} qui appelle {1} avec la signature {2}
msg.not.java.obj =\
 L''argument attendu pour la fonction getClass() doit \u00EAtre un objet Java
msg.no.java.ctor =\
 Le constructeur Java de "{0}" avec les arguments "{1}" est introuvable
msg.method.ambiguous =\
 Le choix de la m\u00E9thode Java {0}.{1} correspondant aux types d''argument JavaScript ({2}) est ambigu. Les m\u00E9thodes propos\u00E9es sont les suivantes : {3}
msg.constructor.ambiguous =\
 Le choix du constructeur Java {0} correspondant aux types d''argument JavaScript ({1}) est ambigu. Les constructeurs propos\u00E9s sont les suivants : {2}
msg.conversion.not.allowed =\
 Impossible de convertir {0} en {1}
msg.not.classloader =\
 Le constructeur de "Packages" attend un argument de type java.lang.Classloader
msg.bad.quant =\
 Le quantificateur {0} est incorrect
msg.overlarge.max =\
 Le maximum {0} est trop important
msg.zero.quant =\
 Le quantificateur {0} est nul
msg.max.lt.min =\
 Le maximum {0} est inf\u00E9rieur au minimum
msg.unterm.quant =\
 Le quantificateur {0} n''a pas de limite
msg.unterm.paren =\
 Les parenth\u00E8ses {0} n''ont pas de limite
msg.unterm.class =\
 La classe de caract\u00E8res {0} n''a pas de limite
msg.bad.range =\
 La classe de caract\u00E8res contient une plage de valeurs incorrecte
msg.trail.backslash =\
 \\ au d\u00E9but d''une expression r\u00E9guli\u00E8re
msg.no.regexp =\
 Les expressions r\u00E9guli\u00E8res ne sont pas disponibles
msg.bad.backref =\
 la r\u00E9f\u00E9rence ant\u00E9rieure d\u00E9passe le nombre de parenth\u00E8ses de capture
msg.dup.label =\
 Le libell\u00E9 {0} existe d\u00E9j\u00E0
msg.undef.label =\
 Le libell\u00E9 {0} n''est pas d\u00E9fini
msg.bad.break =\
 Le saut non libell\u00E9 doit se trouver dans la boucle ou dans l''aiguillage
msg.continue.outside =\
 continue doit se trouver dans la boucle
msg.continue.nonloop =\
 Il n''est possible de continuer que dans l''instruction d''it\u00E9ration libell\u00E9e
msg.fn.redecl =\
 La fonction "{0}" a \u00E9t\u00E9 de nouveau d\u00E9clar\u00E9e. La d\u00E9finition pr\u00E9c\u00E9dente sera ignor\u00E9e
msg.no.paren.parms =\
 il manque ''('' avant les param\u00E8tres de la fonction
msg.no.parm =\
 il manque un param\u00E8tre de forme
msg.no.paren.after.parms =\
 il manque '')'' apr\u00E8s les param\u00E8tres de forme
msg.no.brace.body =\
 il manque '{' avant le corps d''une fonction
msg.no.brace.after.body =\
 il manque ''}'' apr\u00E8s le corps d''une fonction
msg.no.paren.cond =\
 il manque ''('' avant une condition
msg.no.paren.after.cond =\
 il manque '')'' apr\u00E8s une condition
msg.no.semi.stmt =\
 il manque '';'' avant une instruction
msg.no.name.after.dot =\
 il manque un nom apr\u00E8s un op\u00E9rateur ''.''
msg.no.bracket.index =\
 il manque '']'' dans l''expression de l''indice
msg.no.paren.switch =\
 il manque ''('' avant l''expression d''un aiguillage
msg.no.paren.after.switch =\
 il manque '')'' apr\u00E8s l''expression d''un aiguillage
msg.no.brace.switch =\
 il manque '{' avant le corps d''un aiguillage
msg.bad.switch =\
 l''instruction d''aiguillage est incorrecte
msg.no.colon.case =\
 il manque '':'' apr\u00E8s l''expression d''un cas
msg.no.while.do =\
 il manque ''while'' apr\u00E8s le corps d''une boucle do-loop
msg.no.paren.for =\
 il manque ''('' apr\u00E8s for
msg.no.semi.for =\
 Il manque '';'' apr\u00E8s l''initialiseur for-loop
msg.no.semi.for.cond =\
 il manque '';'' apr\u00E8s la condition for-loop
msg.no.paren.for.ctrl =\
 il manque '')'' apr\u00E8s le contrôle for-loop
msg.no.paren.with =\
 il manque ''('' avant un objet with-statement
msg.no.paren.after.with =\
 il manque '')'' apr\u00E8s un objet with-statement
msg.bad.return =\
 la valeur renvoy\u00E9e est incorrecte
msg.no.brace.block =\
 il manque ''}'' dans une instruction compos\u00E9e
msg.bad.label =\
 le libell\u00E9 est incorrect
msg.bad.var =\
 il manque un nom de variable
msg.bad.var.init =\
 l''initialisation de la variable est incorrecte
msg.no.colon.cond =\
 il manque '':'' dans une expression conditionnelle
msg.no.paren.arg =\
 il manque '')'' apr\u00E8s une liste d''arguments
msg.no.bracket.arg =\
 il manque '']'' apr\u00E8s une liste d''\u00E9l\u00E9ments
msg.bad.prop =\
 l''identifiant de propri\u00E9t\u00E9 est incorrect
msg.no.colon.prop =\
 il manque '':'' apr\u00E8s un identifiant de propri\u00E9t\u00E9
msg.no.brace.prop =\
 il manque ''}'' apr\u00E8s une liste de propri\u00E9t\u00E9s
msg.no.paren =\
 il manque '')'' dans des parenth\u00E8ses
msg.reserved.id =\
 l''identifiant est un mot r\u00E9serv\u00E9
msg.no.paren.catch =\
 il manque ''('' avant une condition catch-block
msg.bad.catchcond =\
 la condition catch-block est incorrecte
msg.catch.unreachable =\
 aucune clause catch suivant une interception non qualifi\u00E9e ne peut \u00EAtre atteinte
msg.no.brace.catchblock =\
 il manque '{' avant le corps catch-block
msg.try.no.catchfinally =\
 ''try'' a \u00E9t\u00E9 d\u00E9tect\u00E9 sans ''catch'' ni ''finally''
msg.syntax =\
 erreur de syntaxe
msg.assn.create =\
 Une variable va \u00EAtre cr\u00E9\u00E9e en raison de l''affectation \u00E0 un ''{0}'' non d\u00E9fini. Ajoutez une instruction de variable \u00E0 la port\u00E9e sup\u00E9rieure pour que cet avertissement ne soit plus affich\u00E9
msg.prop.not.found =\
 La propri\u00E9t\u00E9 est introuvable
msg.invalid.type =\
 Valeur JavaScript de type {0} incorrecte
msg.primitive.expected =\
 Un type primitif \u00E9tait attendu (et non {0})
msg.null.to.object =\
 Il est impossible de convertir la valeur null en objet
msg.undef.to.object =\
 Il est impossible de convertir une valeur non d\u00E9finie en objet
msg.cyclic.value =\
 La valeur cyclique {0} n''est pas autoris\u00E9e
msg.is.not.defined =\
 "{0}" n''est pas d\u00E9fini
msg.isnt.function =\
 {0} n''est pas une fonction, est un {1}
msg.bad.default.value =\
 La m\u00E9thode getDefaultValue() de l''objet a renvoy\u00E9 un objet
msg.instanceof.not.object =\
 Il est impossible d''utiliser une instance d''un \u00E9l\u00E9ment autre qu''un objet
msg.instanceof.bad.prototype =\
 La propri\u00E9t\u00E9 ''prototype'' de {0} n''est pas un objet
msg.bad.radix =\
 la base {0} n''est pas autoris\u00E9e
msg.default.value =\
 La valeur par d\u00E9faut de l''objet est introuvable
msg.zero.arg.ctor =\
 Il est impossible de charger la classe "{0}", qui ne poss\u00E8de pas de constructeur de param\u00E8tre z\u00E9ro
msg.multiple.ctors =\
 Les m\u00E9thodes {0} et {1} ont \u00E9t\u00E9 d\u00E9tect\u00E9es alors qu''il est impossible d''utiliser plusieurs m\u00E9thodes constructor
msg.ctor.multiple.parms =\
 Il est impossible de d\u00E9finir le constructeur ou la classe {0} car plusieurs constructeurs poss\u00E8dent plusieurs param\u00E8tres
msg.extend.scriptable =\
 {0} doit \u00E9tendre ScriptableObject afin de d\u00E9finir la propri\u00E9t\u00E9 {1}
msg.bad.getter.parms =\
 Pour d\u00E9finir une propri\u00E9t\u00E9, la m\u00E9thode d''obtention {0} doit avoir des param\u00E8tres z\u00E9ro ou un seul param\u00E8tre ScriptableObject
msg.obj.getter.parms =\
 La m\u00E9thode d''obtention statique ou d\u00E9l\u00E9gu\u00E9e {0} doit utiliser un param\u00E8tre ScriptableObject
msg.getter.static =\
 La m\u00E9thode d''obtention et la m\u00E9thode de d\u00E9finition doivent toutes deux avoir le m\u00EAme \u00E9tat (statique ou non)
msg.setter2.parms =\
 La m\u00E9thode de d\u00E9finition \u00E0 deux param\u00E8tres doit utiliser un param\u00E8tre ScriptableObject comme premier param\u00E8tre
msg.setter1.parms =\
 Une m\u00E9thode d''obtention \u00E0 param\u00E8tre unique est attendue pour {0}
msg.setter2.expected =\
 La m\u00E9thode de d\u00E9finition statique ou d\u00E9l\u00E9gu\u00E9e {0} doit utiliser deux param\u00E8tres
msg.setter.parms =\
 Un ou deux param\u00E8tres sont attendus pour la m\u00E9thode de d\u00E9finition
msg.add.sealed =\
 Il est impossible d''ajouter une propri\u00E9t\u00E9 \u00E0 un objet ferm\u00E9
msg.remove.sealed =\
 Il est impossible de supprimer une propri\u00E9t\u00E9 d''un objet ferm\u00E9
msg.token.replaces.pushback =\
 le jeton de non-obtention {0} remplace le jeton de renvoi {1}
msg.missing.exponent =\
 il manque un exposant
msg.caught.nfe =\
 erreur de format de nombre : {0}
msg.unterminated.string.lit =\
 le litt\u00E9ral de la cha\u00EEne n''a pas de limite
msg.unterminated.comment =\
 le commentaire n''a pas de limite
msg.unterminated.re.lit =\
 le litt\u00E9ral de l''expression r\u00E9guli\u00E8re n''a pas de limite
msg.invalid.re.flag =\
 une expression r\u00E9guli\u00E8re est suivie d''un indicateur incorrect
msg.no.re.input.for =\
 il n''y a pas d''entr\u00E9e pour {0}
msg.illegal.character =\
 caract\u00E8re non autoris\u00E9
msg.invalid.escape =\
 la s\u00E9quence d''\u00E9chappement Unicode est incorrecte
msg.bad.octal.literal =\
 le chiffre octal du litt\u00E9ral, {0}, n''est pas autoris\u00E9 et sera interpr\u00E9t\u00E9 comme un chiffre d\u00E9cimal
msg.reserved.keyword =\
 l''utilisation du futur mot-cl\u00E9 r\u00E9serv\u00E9 {0} n''est pas autoris\u00E9e et celui-ci sera interpr\u00E9t\u00E9 comme un identifiant ordinaire
msg.undefined =\
 La valeur non d\u00E9finie ne poss\u00E8de pas de propri\u00E9t\u00E9
msg.java.internal.field.type =\
 Erreur interne : la conversion de type de {0} afin d''affecter {1} \u00E0 {2} a \u00E9chou\u00E9
msg.java.conversion.implicit_method =\
 La m\u00E9thode de conversion "{0}" est introuvable dans la classe {1}
sg.java.method.assign =\
 La m\u00E9thode Java "{0}" ne peut pas \u00EAtre affect\u00E9e \u00E0
msg.java.internal.private =\
 Erreur interne : une tentative d''acc\u00E9der \u00E0 un champ "{0}" priv\u00E9/prot\u00E9g\u00E9 a \u00E9t\u00E9 d\u00E9tect\u00E9e
msg.java.no_such_method =\
 La m\u00E9thode ''{0}'' est introuvable
msg.script.is.not.constructor =\
 Les objets Script ne sont pas des constructeurs
msg.nonjava.method =\
 La m\u00E9thode Java "{0}" a \u00E9t\u00E9 appel\u00E9e avec une valeur ''this'' qui n''est pas un objet Java
msg.java.member.not.found =\
 La classe Java "{0}" ne poss\u00E8de aucun champ ou aucune m\u00E9thode d''instance publique appel\u00E9 "{1}"
msg.java.array.index.out.of.bounds =\
    Array index {0} is out of bounds [0..{1}].
msg.pkg.int =\
 Les noms de package Java ne peuvent pas \u00EAtre des nombres
msg.ambig.import =\
 Importation ambigu\u00EB : "{0}" et "{1}"
msg.not.pkg =\
 La fonction importPackage doit \u00EAtre appel\u00E9e avec un package et non avec "{0}"
msg.not.class =\
 La fonction importClass doit \u00EAtre appel\u00E9e avec une classe et non avec "{0}"
msg.prop.defined =\
 Il est impossible d''importer "{0}" car une propri\u00E9t\u00E9 portant le m\u00EAme nom a d\u00E9j\u00E0 \u00E9t\u00E9 d\u00E9finie
sg.arraylength.bad =\
 La longueur du tableau n''est pas appropri\u00E9e
msg.bad.uri =\
 La s\u00E9quence URI n''est pas form\u00E9e correctement
msg.bad.precision =\
 La pr\u00E9cision {0} ne se trouve pas dans la plage de valeurs
